#!/usr/bin/env python3
"""
Shorty - Trim MP4/MKV files without re-encoding
"""

import os
import sys
import subprocess
import argparse
from pathlib import Path

# Try to import colorama for colored output
try:
    from colorama import init, Fore, Style
    init(autoreset=True)  # Initialize colorama
    HAS_COLORAMA = True
except ImportError:
    HAS_COLORAMA = False
    # Create dummy color classes if colorama is not available
    class Fore:
        GREEN = ""
        RED = ""
        YELLOW = ""
        CYAN = ""
        WHITE = ""
        RESET = ""
    
    class Style:
        BRIGHT = ""
        RESET_ALL = ""

def parse_time_string(time_str):
    """
    Parse time string in format MM:SS or hHH:MM:SS
    Returns time in seconds
    """
    # Check if this is hours format (starts with 'h')
    if time_str.startswith('h'):
        # Remove the 'h' prefix and parse as HH:MM:SS
        time_part = time_str[1:]
        parts = time_part.split(':')
        if len(parts) == 3:  # HH:MM:SS
            hours, minutes, seconds = map(int, parts)
            return hours * 3600 + minutes * 60 + seconds
        else:
            raise ValueError("Invalid hours format. Use hHH:MM:SS")
    else:
        # Parse as MM:SS (default format)
        parts = time_str.split(':')
        if len(parts) == 2:  # MM:SS
            minutes, seconds = map(int, parts)
            return minutes * 60 + seconds
        elif len(parts) == 3:  # HH:MM:SS
            hours, minutes, seconds = map(int, parts)
            return hours * 3600 + minutes * 60 + seconds
        else:
            raise ValueError("Invalid time format. Use MM:SS, HH:MM:SS, or hHH:MM:SS")

def parse_time_range(time_range_str):
    """
    Parse time range string in format START-END (e.g., "3:10-3:15")
    Returns start_time, end_time in seconds
    """
    if '-' not in time_range_str:
        return None, None
    
    start_str, end_str = time_range_str.split('-', 1)
    try:
        start_time = parse_time_string(start_str)
        end_time = parse_time_string(end_str)
        return start_time, end_time
    except ValueError:
        raise ValueError("Invalid time range format. Use START-END (e.g., '3:10-3:15')")

def get_video_duration(file_path):
    """
    Get video duration using ffprobe
    """
    try:
        cmd = [
            'ffprobe', '-v', 'quiet', '-show_entries', 'format=duration',
            '-of', 'default=noprint_wrappers=1:nokey=1', file_path
        ]
        result = subprocess.run(cmd, capture_output=True, text=True, check=True)
        return float(result.stdout.strip())
    except Exception as e:
        print(f"{Fore.RED}Error getting video duration: {e}{Style.RESET_ALL}")
        return None

def trim_video_to_end(input_file, end_time, output_file):
    """
    Trim video from beginning to end_time using ffmpeg without re-encoding
    """
    try:
        # Build ffmpeg command for stream copying (no re-encoding) with fast seeking
        cmd = [
            'ffmpeg', '-y', '-ss', '0', '-i', input_file,  # Fast seeking from start
            '-t', str(end_time),  # Duration = end_time (from beginning)
            '-c', 'copy',  # Copy all streams without re-encoding
            '-avoid_negative_ts', 'make_zero',
            output_file
        ]
        
        print(f"{Fore.CYAN}Trimming {input_file} to {end_time}s -> {output_file}{Style.RESET_ALL}")
        print(f"{Fore.WHITE}Command: {' '.join(cmd)}{Style.RESET_ALL}")
        
        # Run ffmpeg
        result = subprocess.run(cmd, capture_output=True, text=True)
        
        if result.returncode == 0:
            print(f"{Fore.GREEN}Successfully created {output_file}{Style.RESET_ALL}")
            return True
        else:
            print(f"{Fore.RED}Error trimming {input_file}{Style.RESET_ALL}")
            if result.stderr:
                print(f"  {Fore.RED}Error details: {result.stderr[-200:]}...{Style.RESET_ALL}")
            return False
            
    except Exception as e:
        print(f"{Fore.RED}Error trimming {input_file}: {e}{Style.RESET_ALL}")
        return False

def trim_video(input_file, start_time, output_file):
    """
    Trim video using ffmpeg without re-encoding with fast seeking
    """
    try:
        # Build ffmpeg command for stream copying (no re-encoding) with fast seeking
        cmd = [
            'ffmpeg', '-y', '-ss', str(start_time), '-i', input_file,  # Fast seeking
            '-c', 'copy',  # Copy all streams without re-encoding
            '-avoid_negative_ts', 'make_zero',
            output_file
        ]
        
        print(f"{Fore.CYAN}Trimming {input_file} from {start_time}s -> {output_file}{Style.RESET_ALL}")
        print(f"{Fore.WHITE}Command: {' '.join(cmd)}{Style.RESET_ALL}")
        
        # Run ffmpeg
        result = subprocess.run(cmd, capture_output=True, text=True)
        
        if result.returncode == 0:
            print(f"{Fore.GREEN}Successfully created {output_file}{Style.RESET_ALL}")
            return True
        else:
            print(f"{Fore.RED}Error trimming {input_file}{Style.RESET_ALL}")
            if result.stderr:
                print(f"  {Fore.RED}Error details: {result.stderr[-200:]}...{Style.RESET_ALL}")
            return False
            
    except Exception as e:
        print(f"{Fore.RED}Error trimming {input_file}: {e}{Style.RESET_ALL}")
        return False

def remove_time_range(input_file, start_time, end_time, output_file):
    """
    Remove a time range from the middle of a video using ffmpeg without re-encoding
    This concatenates the part before start_time with the part after end_time
    """
    try:
        print(f"{Fore.CYAN}Removing time range {start_time}s-{end_time}s from {input_file} -> {output_file}{Style.RESET_ALL}")
        
        # Create two segments: before start_time and after end_time
        # First segment: from beginning to start_time (using fast seeking)
        tmp_file1 = f"{output_file}.tmp1{Path(input_file).suffix}"
        cmd1 = [
            'ffmpeg', '-y', '-ss', '0', '-i', input_file,  # Fast seeking from start
            '-t', str(start_time),  # Duration = start_time
            '-c', 'copy',  # Copy all streams without re-encoding
            '-avoid_negative_ts', 'make_zero',
            tmp_file1
        ]
        
        print(f"{Fore.WHITE}Creating first segment: {' '.join(cmd1)}{Style.RESET_ALL}")
        result1 = subprocess.run(cmd1, capture_output=True, text=True)
        
        if result1.returncode != 0:
            print(f"{Fore.RED}Error creating first segment{Style.RESET_ALL}")
            if result1.stderr:
                print(f"  {Fore.RED}Error details: {result1.stderr[-200:]}...{Style.RESET_ALL}")
            # Clean up any temporary files
            if os.path.exists(tmp_file1):
                os.remove(tmp_file1)
            return False
        
        # Second segment: from end_time to end of video (using fast seeking)
        tmp_file2 = f"{output_file}.tmp2{Path(input_file).suffix}"
        cmd2 = [
            'ffmpeg', '-y', '-ss', str(end_time), '-i', input_file,  # Fast seeking
            '-c', 'copy',  # Copy all streams without re-encoding
            '-avoid_negative_ts', 'make_zero',
            tmp_file2
        ]
        
        print(f"{Fore.WHITE}Creating second segment: {' '.join(cmd2)}{Style.RESET_ALL}")
        result2 = subprocess.run(cmd2, capture_output=True, text=True)
        
        if result2.returncode != 0:
            print(f"{Fore.RED}Error creating second segment{Style.RESET_ALL}")
            if result2.stderr:
                print(f"  {Fore.RED}Error details: {result2.stderr[-200:]}...{Style.RESET_ALL}")
            # Clean up any temporary files
            if os.path.exists(tmp_file1):
                os.remove(tmp_file1)
            if os.path.exists(tmp_file2):
                os.remove(tmp_file2)
            return False
        
        # Concatenate the two segments
        # Create a temporary file list for concatenation
        concat_file = f"{output_file}.concat"
        with open(concat_file, 'w') as f:
            f.write(f"file '{os.path.abspath(tmp_file1)}'\n")
            f.write(f"file '{os.path.abspath(tmp_file2)}'\n")
        
        cmd3 = [
            'ffmpeg', '-y', '-f', 'concat', '-safe', '0', '-i', concat_file,
            '-c', 'copy',  # Copy all streams without re-encoding
            output_file
        ]
        
        print(f"{Fore.WHITE}Concatenating segments: {' '.join(cmd3)}{Style.RESET_ALL}")
        result3 = subprocess.run(cmd3, capture_output=True, text=True)
        
        # Clean up temporary files
        if os.path.exists(tmp_file1):
            os.remove(tmp_file1)
        if os.path.exists(tmp_file2):
            os.remove(tmp_file2)
        if os.path.exists(concat_file):
            os.remove(concat_file)
        
        if result3.returncode == 0:
            print(f"{Fore.GREEN}Successfully created {output_file}{Style.RESET_ALL}")
            return True
        else:
            print(f"{Fore.RED}Error concatenating segments{Style.RESET_ALL}")
            if result3.stderr:
                print(f"  {Fore.RED}Error details: {result3.stderr[-200:]}...{Style.RESET_ALL}")
            return False
            
    except Exception as e:
        print(f"{Fore.RED}Error removing time range from {input_file}: {e}{Style.RESET_ALL}")
        # Clean up any temporary files
        if os.path.exists(tmp_file1):
            os.remove(tmp_file1)
        if os.path.exists(tmp_file2):
            os.remove(tmp_file2)
        if os.path.exists(concat_file):
            os.remove(concat_file)
        return False

def process_file(file_path, time_str):
    """
    Process a single video file
    """
    file_path = Path(file_path)
    
    # Check if file exists
    if not file_path.exists():
        print(f"{Fore.RED}Error: File {file_path} does not exist{Style.RESET_ALL}")
        return False
    
    # Check file extension
    if file_path.suffix.lower() not in ['.mp4', '.mkv']:
        print(f"{Fore.RED}Error: Only MP4 and MKV files are supported{Style.RESET_ALL}")
        return False
    
    # Check if this is a negative time format (e.g., "-90")
    if time_str.startswith('-') and time_str[1:].isdigit():
        # Handle negative time format (remove last N seconds)
        try:
            seconds_to_remove = int(time_str[1:])
        except ValueError as e:
            print(f"{Fore.RED}Error parsing negative time: {e}{Style.RESET_ALL}")
            return False
        
        # Get video duration
        duration = get_video_duration(str(file_path))
        if duration is None:
            print(f"{Fore.RED}Could not determine video duration{Style.RESET_ALL}")
            return False
        
        # Validate that we're not removing more than the video duration
        if seconds_to_remove >= duration:
            print(f"{Fore.RED}Error: Cannot remove {seconds_to_remove}s from a {duration:.2f}s video{Style.RESET_ALL}")
            return False
        
        # Calculate end time (duration - seconds_to_remove)
        end_time = duration - seconds_to_remove
        
        # Generate output filename
        output_file = file_path.parent / f"{file_path.stem}_{file_path.suffix}"
        
        # If output file already exists, add a number
        counter = 1
        while output_file.exists():
            output_file = file_path.parent / f"{file_path.stem}_{counter}{file_path.suffix}"
            counter += 1
            # Safety check to prevent infinite loop
            if counter > 100:
                print(f"{Fore.RED}Error: Could not create unique output filename{Style.RESET_ALL}")
                return False
        
        print(f"{Fore.WHITE}Input: {file_path}{Style.RESET_ALL}")
        print(f"{Fore.WHITE}Removing last: {seconds_to_remove}s{Style.RESET_ALL}")
        print(f"{Fore.WHITE}Duration: {duration:.2f}s -> New duration: {end_time:.2f}s{Style.RESET_ALL}")
        print(f"{Fore.WHITE}Output: {output_file}{Style.RESET_ALL}")
        
        # Trim the video from beginning to (duration - seconds_to_remove)
        return trim_video_to_end(str(file_path), end_time, str(output_file))
    
    # Check if this is a time range format (contains '-')
    elif '-' in time_str and not time_str.startswith('-'):
        # Handle time range format (e.g., "3:10-3:15")
        try:
            start_time, end_time = parse_time_range(time_str)
        except ValueError as e:
            print(f"{Fore.RED}Error parsing time range: {e}{Style.RESET_ALL}")
            return False
        
        # Get video duration
        duration = get_video_duration(str(file_path))
        if duration is None:
            print(f"{Fore.RED}Could not determine video duration{Style.RESET_ALL}")
            return False
        
        # Validate time range
        if start_time >= end_time:
            print(f"{Fore.RED}Error: Start time ({start_time}s) must be less than end time ({end_time}s){Style.RESET_ALL}")
            return False
        
        if end_time > duration:
            print(f"{Fore.RED}Error: End time ({end_time}s) is greater than video duration ({duration}s){Style.RESET_ALL}")
            return False
        
        # Generate output filename
        output_file = file_path.parent / f"{file_path.stem}_{file_path.suffix}"
        
        # If output file already exists, add a number
        counter = 1
        while output_file.exists():
            output_file = file_path.parent / f"{file_path.stem}_{counter}{file_path.suffix}"
            counter += 1
            # Safety check to prevent infinite loop
            if counter > 100:
                print(f"{Fore.RED}Error: Could not create unique output filename{Style.RESET_ALL}")
                return False
        
        print(f"{Fore.WHITE}Input: {file_path}{Style.RESET_ALL}")
        print(f"{Fore.WHITE}Removing time range: {time_str} ({start_time}s-{end_time}s){Style.RESET_ALL}")
        print(f"{Fore.WHITE}Duration: {duration:.2f}s{Style.RESET_ALL}")
        print(f"{Fore.WHITE}Output: {output_file}{Style.RESET_ALL}")
        
        # Remove the time range from the video
        return remove_time_range(str(file_path), start_time, end_time, str(output_file))
    else:
        # Handle single time format (original functionality)
        try:
            start_time = parse_time_string(time_str)
        except ValueError as e:
            print(f"{Fore.RED}Error parsing time: {e}{Style.RESET_ALL}")
            return False
        
        # Get video duration
        duration = get_video_duration(str(file_path))
        if duration is None:
            print(f"{Fore.RED}Could not determine video duration{Style.RESET_ALL}")
            return False
        
        # Validate start time
        if start_time >= duration:
            print(f"{Fore.RED}Error: Start time ({start_time}s) is greater than video duration ({duration}s){Style.RESET_ALL}")
            return False
        
        # Generate output filename
        output_file = file_path.parent / f"{file_path.stem}_{file_path.suffix}"
        
        # If output file already exists, add a number
        counter = 1
        original_output_file = output_file
        while output_file.exists():
            output_file = file_path.parent / f"{file_path.stem}_{counter}{file_path.suffix}"
            counter += 1
            # Safety check to prevent infinite loop
            if counter > 100:
                print(f"{Fore.RED}Error: Could not create unique output filename{Style.RESET_ALL}")
                return False
        
        print(f"{Fore.WHITE}Input: {file_path}{Style.RESET_ALL}")
        print(f"{Fore.WHITE}Start time: {time_str} ({start_time}s){Style.RESET_ALL}")
        print(f"{Fore.WHITE}Duration: {duration:.2f}s{Style.RESET_ALL}")
        print(f"{Fore.WHITE}Output: {output_file}{Style.RESET_ALL}")
        
        # Trim the video
        return trim_video(str(file_path), start_time, str(output_file))

def main():
    if len(sys.argv) != 3:
        print(f"{Fore.CYAN}{Style.BRIGHT}Shorty - Trim MP4/MKV files without re-encoding{Style.RESET_ALL}")
        print(f"{Fore.WHITE}Usage: python3 shorty 'MM:SS' file.mp4{Style.RESET_ALL}")
        print(f"{Fore.WHITE}       python3 shorty 'HH:MM:SS' file.mkv{Style.RESET_ALL}")
        print(f"{Fore.WHITE}       python3 shorty 'hHH:MM:SS' file.mp4{Style.RESET_ALL}")
        print(f"{Fore.WHITE}       python3 shorty 'MM:SS-MM:SS' file.mp4{Style.RESET_ALL}")
        print(f"{Fore.WHITE}       python3 shorty 'hHH:MM:SS-hHH:MM:SS' file.mp4{Style.RESET_ALL}")
        print(f"{Fore.WHITE}       python3 shorty '-SECONDS' file.mp4{Style.RESET_ALL}")
        print(f"{Fore.WHITE}Example: python3 shorty '3:10' video.mp4{Style.RESET_ALL}")
        print(f"{Fore.WHITE}         (Removes the first 3 minutes and 10 seconds from video.mp4){Style.RESET_ALL}")
        print(f"{Fore.WHITE}         python3 shorty 'h1:30:00' video.mp4{Style.RESET_ALL}")
        print(f"{Fore.WHITE}         (Removes the first 1 hour 30 minutes from video.mp4){Style.RESET_ALL}")
        print(f"{Fore.WHITE}         python3 shorty '3:10-3:15' video.mp4{Style.RESET_ALL}")
        print(f"{Fore.WHITE}         (Removes 5 seconds from the middle of video.mp4){Style.RESET_ALL}")
        print(f"{Fore.WHITE}         python3 shorty 'h1:20:00-h1:25:00' video.mp4{Style.RESET_ALL}")
        print(f"{Fore.WHITE}         (Removes 5 minutes from the middle of video.mp4){Style.RESET_ALL}")
        print(f"{Fore.WHITE}         python3 shorty '-90' video.mp4{Style.RESET_ALL}")
        print(f"{Fore.WHITE}         (Removes the last 90 seconds from video.mp4){Style.RESET_ALL}")
        return
    
    time_str = sys.argv[1]
    input_file = sys.argv[2]
    
    print(f"{Fore.CYAN}{Style.BRIGHT}Shorty - Video Trimmer{Style.RESET_ALL}")
    
    success = process_file(input_file, time_str)
    
    if success:
        print(f"{Fore.GREEN}{Style.BRIGHT}Processing completed successfully!{Style.RESET_ALL}")
    else:
        print(f"{Fore.RED}{Style.BRIGHT}Processing failed!{Style.RESET_ALL}")
        sys.exit(1)

if __name__ == "__main__":
    main()