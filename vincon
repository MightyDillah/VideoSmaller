#!/usr/bin/env python3

import subprocess
import json
import os
import sys
import platform
from pathlib import Path
import time

# Maximum bitrate limit (20 Mbps - safe for 4K Blu-ray quality)
MAX_BITRATE = 20000  # kbps

def get_video_info(file_path):
    """Extract comprehensive video information using ffprobe"""
    # First try to get basic format info
    format_cmd = [
        'ffprobe', '-v', 'quiet', '-print_format', 'json', '-show_format', file_path
    ]
    
    # Then get stream info
    stream_cmd = [
        'ffprobe', '-v', 'quiet', '-print_format', 'json', '-show_streams', file_path
    ]
    
    try:
        # Get format information
        format_result = subprocess.run(format_cmd, capture_output=True, text=True, check=True, timeout=15)
        format_info = json.loads(format_result.stdout)
        
        # Get stream information
        stream_result = subprocess.run(stream_cmd, capture_output=True, text=True, check=True, timeout=15)
        stream_info = json.loads(stream_result.stdout)
        
        # Combine both
        combined_info = format_info
        combined_info['streams'] = stream_info.get('streams', [])
        
        return combined_info
    except subprocess.TimeoutExpired:
        print(f"Timeout getting video info for {file_path}")
        return None
    except subprocess.CalledProcessError as e:
        print(f"Error getting video info for {file_path}: {e}")
        return None
    except json.JSONDecodeError as e:
        print(f"Error parsing video info for {file_path}: {e}")
        return None
    except Exception as e:
        print(f"Unexpected error getting video info for {file_path}: {e}")
        return None

def parse_video_info(info, file_path):
    """Parse video information to extract relevant encoding parameters"""
    if not info:
        return None
        
    video_stream = None
    audio_stream = None
    
    # Find video and audio streams
    for stream in info.get('streams', []):
        if stream.get('codec_type') == 'video' and video_stream is None:
            video_stream = stream
        elif stream.get('codec_type') == 'audio' and audio_stream is None:
            audio_stream = stream
    
    if not video_stream:
        print(f"No video stream found in {file_path}")
        return None
    
    # Extract video parameters
    width = video_stream.get('width')
    height = video_stream.get('height')
    
    # Handle different frame rate representations
    fps = 30.0  # Default fallback
    avg_frame_rate = video_stream.get('avg_frame_rate')
    r_frame_rate = video_stream.get('r_frame_rate')
    
    # Try avg_frame_rate first, then r_frame_rate
    frame_rate_source = avg_frame_rate or r_frame_rate
    if frame_rate_source:
        try:
            parts = frame_rate_source.split('/')
            if len(parts) == 2 and float(parts[1]) != 0:
                fps = float(parts[0]) / float(parts[1])
            else:
                fps = float(frame_rate_source)
        except:
            fps = 30.0  # Default fallback
    
    # Get bit rate from multiple sources
    bit_rate = None
    
    # Try video stream bitrate first
    if 'bit_rate' in video_stream and video_stream['bit_rate'] is not None:
        try:
            bit_rate = max(100, int(video_stream['bit_rate']) // 1000)  # Convert to kbps, min 100
        except:
            pass
    
    # Try format bitrate if stream bitrate not available
    if not bit_rate and 'format' in info and 'bit_rate' in info['format'] and info['format']['bit_rate'] is not None:
        try:
            bit_rate = max(100, int(info['format']['bit_rate']) // 1000)  # Convert to kbps, min 100
        except:
            pass
    
    # Get pixel format
    pix_fmt = video_stream.get('pix_fmt', 'yuv420p')  # Default fallback
    
    # Map to supported formats for videotoolbox
    supported_formats = ['nv12', 'yuv420p', 'bgra', 'ayuv', 'p010le', 'p210le']
    if pix_fmt not in supported_formats:
        # Fallback to yuv420p if not supported
        pix_fmt = 'yuv420p'
    
    # Handle special case for very low bitrates
    if bit_rate and bit_rate < 100:
        bit_rate = 100
    
    return {
        'width': width,
        'height': height,
        'fps': round(fps, 3),
        'bit_rate': bit_rate,
        'pix_fmt': pix_fmt
    }

def detect_available_encoders():
    """Detect which HEVC encoders are available in ffmpeg"""
    try:
        result = subprocess.run(['ffmpeg', '-encoders'], capture_output=True, text=True, check=True)
        encoders_output = result.stdout
        
        available_encoders = {}
        
        # Check for Apple VideoToolbox encoder
        if 'hevc_videotoolbox' in encoders_output:
            available_encoders['videotoolbox'] = 'hevc_videotoolbox'
        
        # Check for AMD AMF encoder
        if 'hevc_amf' in encoders_output:
            available_encoders['amf'] = 'hevc_amf'
        
        # Check for NVIDIA NVENC encoder
        if 'hevc_nvenc' in encoders_output:
            available_encoders['nvenc'] = 'hevc_nvenc'
            
        # Check for Intel QSV encoder
        if 'hevc_qsv' in encoders_output:
            available_encoders['qsv'] = 'hevc_qsv'
        
        return available_encoders
    except Exception as e:
        print(f"Error detecting encoders: {e}")
        # Return default based on platform if detection fails
        import platform
        system = platform.system().lower()
        if system == 'darwin':  # macOS
            return {'videotoolbox': 'hevc_videotoolbox'}
        else:
            # On other systems, assume common encoders might be available
            return {}

def get_best_encoder():
    """Get the best available HEVC encoder based on platform"""
    encoders = detect_available_encoders()
    
    # Encoder priority based on quality and performance
    encoder_priority = ['videotoolbox', 'nvenc', 'amf', 'qsv']
    
    for encoder_name in encoder_priority:
        if encoder_name in encoders:
            encoder = encoders[encoder_name]
            print(f"Using {encoder} encoder")
            return encoder, encoder_name
    
    # If no hardware encoder found, fall back to software
    print("No hardware encoder found, using software encoder")
    return 'libx265', 'software'

def convert_video(input_file, video_params):
    """Convert video using ffmpeg with the best available hardware encoding"""
    if not video_params:
        print(f"Could not determine parameters for {input_file}")
        return False
    
    # Generate output filename (same name, different extension)
    input_path = Path(input_file)
    output_file = input_path.parent / f"{input_path.stem}.mp4"
    
    # If input is already .mp4, add _out suffix to avoid overwriting
    if input_path.suffix.lower() == '.mp4':
        output_file = input_path.parent / f"{input_path.stem}_out.mp4"
    
    # Detect and get the best available encoder
    encoder, encoder_type = get_best_encoder()
    
    # Prepare ffmpeg command with enhanced options
    cmd = [
        'ffmpeg', '-y', '-i', input_file,  # Overwrite output files
        '-c:v', encoder,  # Use best available hardware encoding
        '-pix_fmt', video_params['pix_fmt'],
        '-c:a', 'aac',  # Audio codec
        '-ar', '44100',  # Audio sample rate
        '-b:a', '128k',  # Audio bitrate
        '-ac', '2',  # Audio channels
        '-movflags', 'faststart',  # Optimize for streaming and compatibility
        '-profile:v', 'main'  # Use main profile for wide compatibility
    ]
    
    # Add encoder-specific options
    if encoder_type == 'amf':  # AMD AMF encoder
        cmd.extend([
            '-quality', 'balanced',  # Quality preset for AMF
            '-usage', 'transcoding'  # Usage preset for AMF
        ])
    elif encoder_type == 'nvenc':  # NVIDIA NVENC encoder
        cmd.extend([
            '-preset', 'p7',  # Performance preset for NVENC
            '-tune', 'hq'  # Tune for high quality
        ])
    elif encoder_type == 'qsv':  # Intel QSV encoder
        cmd.extend([
            '-preset', 'veryfast'  # Performance preset for QSV
        ])
    elif encoder_type == 'videotoolbox':  # Apple VideoToolbox encoder
        cmd.extend([
            '-vtag', 'hvc1',  # Use hvc1 codec tag for better macOS compatibility
        ])
    
    # Add video bitrate if available, with maximum limit
    if video_params['bit_rate']:
        # Preserve original bitrate for quality matching, but cap at maximum
        hevc_bitrate = min(max(100, video_params['bit_rate']), MAX_BITRATE)
        cmd.extend(['-b:v', f'{hevc_bitrate}k'])
    
    # Add frame rate
    cmd.extend(['-r', str(video_params['fps'])])
    
    # Add output file
    cmd.append(str(output_file))
    
    print(f"Converting {input_file} -> {output_file}")
    print(f"Parameters: {video_params}")
    print(f"Encoder: {encoder}")
    if video_params['bit_rate']:
        print(f"Target bitrate: {video_params['bit_rate']} kbps")
    
    try:
        # Run ffmpeg with real-time output
        start_time = time.time()
        process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True, bufsize=1)
        
        # Print output in real-time
        for line in process.stdout:
            print(line.strip())
        
        process.wait()
        end_time = time.time()
        
        if process.returncode == 0:
            print(f"Successfully converted {input_file} in {end_time - start_time:.1f} seconds")
            return True
        else:
            print(f"Error converting {input_file}")
            return False
    except Exception as e:
        print(f"Exception during conversion of {input_file}: {e}")
        return False

def process_directory(directory):
    """Process all video files in a directory as a batch"""
    # Supported video extensions (excluding MP4 and MKV as requested)
    video_extensions = {'.avi', '.mpg', '.mpeg', '.wmv', '.mov', '.flv'}
    
    # Find all video files in directory
    video_files = []
    dir_path = Path(directory)
    
    # Validate directory
    if not dir_path.exists():
        print(f"Error: Directory {directory} does not exist")
        return False
    
    if not dir_path.is_dir():
        print(f"Error: {directory} is not a directory")
        return False
    
    # Collect video files and sort alphabetically
    for file_path in dir_path.iterdir():
        if file_path.is_file() and file_path.suffix.lower() in video_extensions:
            video_files.append(str(file_path))
    
    # Sort files alphabetically (case-insensitive)
    video_files.sort(key=str.lower)
    
    if not video_files:
        print(f"No video files found in {directory}")
        return False
    
    print(f"Found {len(video_files)} video files to process (sorted alphabetically)")
    
    # Create a processing list
    print("\nProcessing list:")
    for i, file_path in enumerate(video_files, 1):
        print(f"  {i:2d}. {Path(file_path).name}")
    
    # Pre-repair phase for damaged files
    print("\n[PRE-REPAIR PHASE] Checking for damaged files...")
    for i, file_path in enumerate(video_files, 1):
        print(f"[{i}/{len(video_files)}] Checking {Path(file_path).name}...")
        input_path = Path(file_path)
        
        # Get original file size
        original_size = input_path.stat().st_size
        
        # Only attempt repair on potentially problematic formats
        if input_path.suffix.lower() in ['.mpeg', '.mpg', '.avi', '.wmv']:
            try:
                # Create temporary repaired file
                temp_path = input_path.with_name(f"{input_path.stem}_temp{input_path.suffix}")
                
                # Run repair command
                repair_cmd = [
                    'ffmpeg', '-y', '-i', str(input_path),
                    '-c', 'copy',
                    '-avoid_negative_ts', 'make_zero',
                    '-fflags', '+genpts',
                    str(temp_path)
                ]
                
                print(f"      Attempting repair...")
                repair_result = subprocess.run(repair_cmd, capture_output=True, text=True, timeout=300)
                
                if repair_result.returncode == 0 and temp_path.exists():
                    # Get repaired file size
                    repaired_size = temp_path.stat().st_size
                    
                    # Check if file is significantly damaged (less than 1MB or less than 10% of original)
                    if repaired_size > 1000000 and repaired_size > (original_size / 10):
                        # File seems OK, replace original (no backup)
                        input_path.unlink()
                        temp_path.rename(input_path)
                        print(f"      ✓ Repaired successfully")
                    else:
                        # File appears damaged, rename original and keep repaired version
                        input_path.rename(input_path.with_name(f"{input_path.stem}_damaged{input_path.suffix}"))
                        temp_path.rename(input_path)
                        print(f"      ! File may be damaged (keeping repaired version)")
                else:
                    # Repair failed, remove temp file if it exists
                    if temp_path.exists():
                        temp_path.unlink()
                    print(f"      - Repair not needed or failed")
            except Exception as e:
                print(f"      - Repair error: {e}")
    
    # Refresh file list after pre-repair
    video_files = []
    for file_path in dir_path.iterdir():
        if file_path.is_file() and file_path.suffix.lower() in video_extensions:
            video_files.append(str(file_path))
    video_files.sort(key=str.lower)
    
    # First pass: analyze all files
    print("\n[ANALYSIS PHASE] Analyzing video files...")
    file_params = {}
    failed_analysis = []
    
    for i, file_path in enumerate(video_files, 1):
        print(f"[{i}/{len(video_files)}] Analyzing {Path(file_path).name}...")
        info = get_video_info(file_path)
        params = parse_video_info(info, file_path)
        if params:
            file_params[file_path] = params
            print(f"      ✓ Resolution: {params['width']}x{params['height']}")
            print(f"      ✓ Frame rate: {params['fps']} fps")
            if params['bit_rate']:
                print(f"      ✓ Bit rate: {params['bit_rate']} kbps")
            else:
                print(f"      - Bit rate: Unknown")
            print(f"      ✓ Pixel format: {params['pix_fmt']}")
        else:
            print(f"      ✗ Failed to analyze {Path(file_path).name}")
            failed_analysis.append(file_path)
    
    # Report analysis results
    print(f"\nAnalysis completed: {len(file_params)} successful, {len(failed_analysis)} failed")
    
    # Second pass: convert all files with successful analysis
    print("\n[CONVERSION PHASE] Converting video files...")
    successful_conversions = 0
    failed_conversions = []
    
    # Convert files with progress tracking
    conversion_list = list(file_params.items())
    for i, (file_path, params) in enumerate(conversion_list, 1):
        print(f"\n[{i}/{len(conversion_list)}] Processing {Path(file_path).name}...")
        success = convert_video(file_path, params)
        if success:
            successful_conversions += 1
            print(f"      ✓ Successfully converted")
        else:
            failed_conversions.append(file_path)
            print(f"      ✗ Conversion failed")
    
    # Report results
    print(f"\n{'='*60}")
    print(f"CONVERSION SUMMARY")
    print(f"{'='*60}")
    print(f"Total files found: {len(video_files)}")
    print(f"Successfully converted: {successful_conversions}")
    print(f"Failed conversions: {len(failed_conversions)}")
    
    if failed_conversions:
        print(f"\nFailed files:")
        for file_path in failed_conversions:
            print(f"  - {Path(file_path).name}")
    
    if failed_analysis:
        print(f"\nFiles that failed analysis (not converted): {len(failed_analysis)}")
        for file_path in failed_analysis:
            print(f"  - {Path(file_path).name}")
    
    # Create a final list of processed files
    print(f"\nFinal processing list:")
    processed_count = 0
    for file_path in video_files:
        filename = Path(file_path).name
        if file_path in failed_analysis:
            print(f"  {filename:<30} [ANALYSIS FAILED]")
        elif file_path in failed_conversions:
            print(f"  {filename:<30} [CONVERSION FAILED]")
        else:
            processed_count += 1
            output_filename = f"{Path(file_path).stem}.mp4"
            print(f"  {filename:<30} [CONVERTED] -> {output_filename}")
    
    print(f"\nProcessed {processed_count}/{len(video_files)} files successfully")
    
    return successful_conversions > 0

def fix_mp4_files(directory):
    """Add macOS compatibility tags to existing MP4 files"""
    dir_path = Path(directory)
    
    # Validate directory
    if not dir_path.exists():
        print(f"Error: Directory {directory} does not exist")
        return False
    
    if not dir_path.is_dir():
        print(f"Error: {directory} is not a directory")
        return False
    
    # Find all MP4 files in directory
    mp4_files = []
    for file_path in dir_path.iterdir():
        if file_path.is_file() and file_path.suffix.lower() == '.mp4':
            mp4_files.append(str(file_path))
    
    if not mp4_files:
        print(f"No MP4 files found in {directory}")
        return False
    
    print(f"Found {len(mp4_files)} MP4 files to fix")
    
    # Fix each MP4 file
    successful_fixes = 0
    failed_fixes = []
    
    for i, file_path in enumerate(mp4_files, 1):
        print(f"[{i}/{len(mp4_files)}] Fixing {Path(file_path).name}...")
        input_path = Path(file_path)
        temp_path = input_path.with_name(f"{input_path.stem}_temp.mp4")
        
        try:
                # Run fix command with macOS compatibility tags
                fix_cmd = [
                    'ffmpeg', '-y', '-i', str(input_path),
                    '-c', 'copy',  # Copy streams without re-encoding
                    '-movflags', 'faststart',  # Optimize for streaming
                    '-vtag', 'hvc1',  # Use hvc1 codec tag for better macOS compatibility
                    '-profile:v', '1',  # Main profile for HEVC
                    str(temp_path)
                ]
                
                print(f"      Adding macOS compatibility tags...")
                fix_result = subprocess.run(fix_cmd, capture_output=True, text=True, timeout=300)
                
                if fix_result.returncode == 0 and temp_path.exists():
                    # Replace original with fixed version (no backup)
                    input_path.unlink()
                    temp_path.rename(input_path)
                    print(f"      ✓ Fixed successfully")
                    successful_fixes += 1
                else:
                    # Fix failed, remove temp file if it exists
                    if temp_path.exists():
                        temp_path.unlink()
                    print(f"      ✗ Fix failed: {fix_result.stderr[-200:] if fix_result.stderr else 'Unknown error'}")
                    failed_fixes.append(file_path)
        except Exception as e:
            print(f"      ✗ Fix error: {e}")
            failed_fixes.append(file_path)
    
    # Report results
    print(f"\n{'='*50}")
    print(f"MP4 FIX SUMMARY")
    print(f"{'='*50}")
    print(f"Total MP4 files found: {len(mp4_files)}")
    print(f"Successfully fixed: {successful_fixes}")
    print(f"Failed fixes: {len(failed_fixes)}")
    
    if failed_fixes:
        print(f"\nFailed files:")
        for file_path in failed_fixes:
            print(f"  - {Path(file_path).name}")
    
    return successful_fixes > 0

def main():
    if len(sys.argv) < 2 or len(sys.argv) > 3:
        print("Video Converter - Convert videos to HEVC using available hardware encoder")
        print("")
        print("Usage: vincon <directory>")
        print("       vincon -fixmp4 <directory>")
        print("")
        print("Processes all video files in the specified directory.")
        print("Automatically detects and uses the best available hardware encoder:")
        print("  - Apple VideoToolbox (macOS)")
        print("  - AMD AMF (Windows/Linux with AMD GPU)")
        print("  - NVIDIA NVENC (Windows/Linux with NVIDIA GPU)")
        print("  - Intel QSV (Windows/Linux with Intel GPU)")
        print("Supported formats: AVI, MPG, MPEG, WMV, MOV, FLV (MP4/MKV skipped)")
        print("Output: Same filename with .mp4 extension")
        print("")
        return
    
    # Check for fixmp4 flag
    if len(sys.argv) == 3 and sys.argv[1] == "-fixmp4":
        directory = sys.argv[2]
        success = fix_mp4_files(directory)
        if success:
            print("\nMP4 fixing completed successfully!")
        else:
            print("\nMP4 fixing completed with errors.")
        return
    elif len(sys.argv) == 2 and sys.argv[1] == "-fixmp4":
        print("Error: -fixmp4 requires a directory argument")
        return
    elif sys.argv[1].startswith("-") and sys.argv[1] != "-fixmp4":
        print(f"Error: Unknown flag {sys.argv[1]}")
        return
    
    # Process the directory (normal conversion)
    directory = sys.argv[1]
    success = process_directory(directory)
    
    if success:
        print("\nProcessing completed successfully!")
    else:
        print("\nProcessing completed with errors.")
        sys.exit(1)

if __name__ == "__main__":
    main()
